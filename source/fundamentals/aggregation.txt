.. _golang-aggregation:

===========
Aggregation
===========

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Overview
--------

In this guide, you can learn how to use **aggregation operations** in the
{+driver-long+}.

Aggregation operations process data in your MongoDB collections based on
your specifications in the **aggregation pipeline**. An aggregation
pipeline consists of one or more **stages**. Each stage performs an
operation based on its expression operators. After the driver executes
the aggregation pipeline, it returns an aggregated result.

Analogy
~~~~~~~

Aggregation operations operate similarly to a car factory. Car factories
have an assembly line. The assembly lines have assembly stations with
specialized tools to peform a specific task. To build a car, you send
raw parts to the factory. Then, the assembly line transforms and
assembles the parts into a car.

The assembly line resembles the **aggregation pipeline**, the assembly
stations in the assembly line resemble the **aggregation stages**, the
specialized tools represent the **expression operators**, and the
finished product resembles the **aggregated result**. 

Compare Operations
------------------

The following table lists the tasks you can perform with find and aggregation operations.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Find Operations
     - Aggregation Operations

   * - | Select *what* documents to return
       | Select *which* fields to return
       | Sort the results
       | Limit the results
       | Count the results
     - | Select *what* documents to return
       | Select *which* fields to return
       | Sort the results
       | Limit the results
       | Count the results
       | Rename fields
       | Calculate fields
       | Summarize data
       | Group values

Limitations
-----------

Aggregation operations have limitations. When performing agregation
operations, keep the following in mind:

- Returned documents must not violate the :manual:`BSON document size
  limit </reference/limits/#BSON-Document-Size>` of 16 megabytes.
- Pipeline stages have a memory limit of 100 megabytes by default. If
  required, you may exceed this limit by using the `allowDiskUse
  <{+api+}/mongo/options#AggregateOptions.SetAllowDiskUse>`__
  method.
- The :manual:`$graphLookup
  </reference/operator/aggregation/graphLookup/>` stage
  has a strict memory limit of 100 megabytes and ignores
  ``allowDiskUse``.

Examples
--------

To run the examples in this section, load the sample data into the
``tea.ratings`` collection with the following snippet:

.. literalinclude:: /includes/fundamentals/code-snippets/aggregation.go
   :start-after: begin insert docs
   :end-before: end insert docs
   :language: go
   :dedent:

Each document represents a person's rating for a particular tea, and the
amount of visits they made to a local tea shop.

Average Rating
~~~~~~~~~~~~~~

The following example calculates and displays the average rating and
amount of ratings for each tea.

The aggregation pipleline uses the ``$group`` stage to group the
documents by the ``type`` field, calculates the average using the
``$avg`` expression operator, and counts the number of documents using
the ``$sum`` expression operator.

.. io-code-block::
   :copyable: true

   .. input::
      :language: go

      // create the stage
      groupStage := bson.D{
          {"$group", bson.D{
              {"_id", "$type"},
              {"average", bson.D{
                  {"$avg", "$rating"},
              }},
              {"count", bson.D{
                  {"$sum", 1},
              }},
      }}}

      // pass the stage into a pipeline
      // pass the pipeline as the second paramter in the Aggregate() method
      cursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{groupStage})
      if err != nil {
          panic(err)
      }

      // display the results
      var results []bson.M
      if err = cursor.All(context.TODO(), &results); err != nil {
          panic(err)
      }
      for _, result := range results {
          fmt.Printf("%v has an average rating of %v \n", result["_id"], result["average"])
          fmt.Printf("%v Count: %v \n", result["_id"], result["count"])
      }

   .. output::
      :language: go

      Masala has an average rating of 8.363636363636363 
      Masala Count: 11 
      Earl Grey has an average rating of 7.375 
      Earl Grey Count: 8 

Omit Fields in Results
~~~~~~~~~~~~~~~~~~~~~~

The following example matches documents with ratings over 8 for each tea
and displays the top 5 highest ratings tea types and the amount of
visits.

The aggregation pipleline contains the following stages:

- ``$match`` stage to match documents with a ``rating`` greater than 8
- ``$unset`` stage to omit the ``_id`` and ``rating`` fields
- ``$sort`` stage to sort the ``visits`` in descending order and the ``type`` in
  ascending order
- ``$limit`` stage to show the first five documents

.. io-code-block::
   :copyable: true

   .. input::
      :language: go

      // create the stages
      matchStage := bson.D{{"$match", bson.D{
          {"rating", bson.D{
              {"$gt", 8}},
          }},
      }}
      unsetStage := bson.D{{"$unset",bson.A{"_id", "rating"},}}
      sortStage := bson.D{{"$sort", bson.D{
          {"visits", -1},
          {"type", 1}},
      }}
      limitStage := bson.D{{"$limit", 5}}

      // pass the stage into a pipeline
      // pass the pipeline as the second paramter in the Aggregate() method
      cursor, err := coll.Aggregate(context.TODO(), mongo.Pipeline{matchStage, unsetStage, sortStage, limitStage})
      if err != nil {
          panic(err)
      }

      // display the results
      		var results []bson.M
      if err = cursor.All(context.TODO(), &results); err != nil {
          panic(err)
      }
      for _, result := range results {
          fmt.Println(result)
      }

   .. output::
      :language: go

      map[type:Masala visits:24]
      map[type:Masala visits:24]
      map[type:Masala visits:21]
      map[type:Masala visits:20]
      map[type:Earl Grey visits:19]

Additional Information
----------------------

To learn more about the terms mentioned, see the following
guides:

- :manual:`Expression Operators </reference/operator/aggregation/>`
- :manual:`Aggregation Pipeline </core/aggregation-pipeline/>`
- :manual:`Aggregation Stages </meta/aggregation-quick-reference/#stages>`
- :manual:`Operator Expressions </meta/aggregation-quick-reference/#operator-expressions>`
- :manual:`Aggregation Pipeline Limits </core/aggregation-pipeline-limits/>`

To view more aggregation examples, see the following guides:

- :ref:`Count <golang-count-aggregation>`
- :ref:`Limit <golang-limit-aggregation>`
- :ref:`Skip <golang-skip-aggregation>`
- :ref:`Text <golang-search-text-aggregation>`

To learn more about the ``Aggregate()`` method and its behavior, see
:ref:`Retrieve Data <golang-retrieve-aggregation>`.

API Documentation
~~~~~~~~~~~~~~~~~

To learn more about any of the methods or types discussed in this
guide, see the following API Documentation:

- `Aggregate() <{+api+}/mongo#Collection.Aggregate>`__
- `AggregateOptions <{+api+}/mongo/options#AggregateOptions>`__

